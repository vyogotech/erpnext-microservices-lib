{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Frappe Microservice Framework","text":"<p>A Python library for building secure, multi-tenant Frappe microservices with minimal boilerplate and a clear separation of concerns.</p>"},{"location":"#core-principles","title":"Core Principles","text":"<ul> <li>Secure by Default: All endpoints require authentication unless explicitly public.</li> <li>Multi-Tenant Isolation: Data is automatically segregated by tenant, preventing data leaks.</li> <li>Gradual Decomposition: Designed for the incremental migration of ERPNext modules into microservices.</li> <li>Bounded Context: Each microservice manages its own database schema and logic, promoting true service independence.</li> <li>Frappe-Compatible: Leverages Frappe's ORM and conventions while enabling modern development patterns.</li> </ul>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"<ul> <li>\ud83d\udd12 Secure by Default: All endpoints require authentication via Central Site.</li> <li>\ud83d\udd0c Independent Database: Each microservice has its own database (bounded context principle).</li> <li>\ud83d\udc64 User Context Injection: Authenticated user is automatically injected into handlers.</li> <li>\ud83d\ude80 Zero Boilerplate: Create CRUD APIs with a single line of code.</li> <li>\ud83c\udfe2 Multi-Tenant Ready: Built-in support for tenant isolation.</li> <li>\ud83d\udee1\ufe0f Tenant-Aware Database: Automatic <code>tenant_id</code> filtering prevents cross-tenant data access.</li> <li>\ud83e\ude9d Document Hooks: Frappe-style lifecycle hooks without modifying Frappe core.</li> <li>\ud83d\udce6 Frappe-Native: Seamlessly works with Frappe DocTypes and APIs.</li> <li>\ud83d\udcca Observability: Built-in OpenTelemetry tracing and configurable logging.</li> <li>\ud83c\udfd7\ufe0f Professional CI/CD: Automated testing, reporting (Allure), and branch-based Docker tagging.</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Getting Started</li> <li>Architecture &amp; Isolation</li> <li>Core Features</li> <li>Observability</li> <li>CI/CD &amp; Release Strategy</li> <li>Developer Guide</li> </ul>"},{"location":"architecture/","title":"Architecture &amp; Isolation","text":""},{"location":"architecture/#bounded-context","title":"Bounded Context","text":"<p>In a true microservices architecture, each service must own its data. The Frappe Microservice Framework promotes this by encouraging an Independent Database for each service.</p> <ul> <li>Central Site: Acts as the \"Source of Truth\" for authentication and global user state.</li> <li>Service Database: Contains only the DocTypes relevant to the service's bounded context.</li> </ul>"},{"location":"architecture/#external-dependencies","title":"External Dependencies","text":""},{"location":"architecture/#central-site-saas_platform-app","title":"Central Site &amp; <code>saas_platform</code> App","text":"<p>The framework relies on a Central Site running a specific Frappe app called saas_platform.</p> <ul> <li>Tenant Identification: The <code>saas_platform</code> app is responsible for adding the <code>tenant_id</code> field to the <code>User</code> DocType on the Central Site.</li> <li>Session Validation: When a microservice validates a session, it expects the Central Site to return a user profile that includes this <code>tenant_id</code>.</li> <li>Data Isolation: Without the <code>saas_platform</code> app on the Central Site, the microservice will not be able to resolve the user's tenant, effectively disabling multi-tenant data isolation.</li> </ul>"},{"location":"architecture/#strategy-granular-decomposition-of-erpnext","title":"Strategy: Granular Decomposition of ERPNext","text":"<p>One of the primary goals of this framework is to enable the gradual decomposition of monolithic ERPNext into smaller, manageable microservices.</p> <p>Instead of a high-risk \"big bang\" migration, teams can: 1.  Identify a Module: Choose a specific module (e.g., \"Orders\", \"Signups\", \"Inventory\"). 2.  Define a Bounded Context: Extract relevant DocTypes to a new service-specific database. 3.  Implement via Framework: Use the Frappe Microservice Framework to expose APIs and business logic. 4.  Secure Integration: Leverage the Central Site for unified authentication across all microservices.</p> <p>This approach allows for independent scaling, faster deployment cycles, and technology diversification while maintaining the power of Frappe's DocType system.</p>"},{"location":"architecture/#multi-tenancy","title":"Multi-Tenancy","text":"<p>The framework is built for SaaS applications. It assumes a \"Single Site, Multi-Tenant\" model where data is isolated using a <code>tenant_id</code> field.</p>"},{"location":"architecture/#tenantawaredb","title":"TenantAwareDB","text":"<p>The <code>app.tenant_db</code> object is a wrapper around Frappe's database methods. It automatically ensures that: 1.  Filtering: All <code>get_all</code> calls include a <code>tenant_id</code> filter in the <code>WHERE</code> clause. 2.  Validation: All <code>get_doc</code> calls verify that the requested document belongs to the current user's tenant. 3.  Inheritance: All <code>insert_doc</code> calls automatically set the <code>tenant_id</code> from the current request context.</p>"},{"location":"architecture/#authentication-identification","title":"Authentication &amp; Identification","text":"<ol> <li>A user logs in to the Central Site.</li> <li>The microservice receives the request with the <code>sid</code> cookie.</li> <li><code>MicroserviceApp</code> validates the session against the Central Site.</li> <li>The user's <code>tenant_id</code> is resolved and stored in the request context (<code>flask.g</code>).</li> <li>All database operations are now scoped to that <code>tenant_id</code>.</li> </ol>"},{"location":"architecture/#database-diagram-example","title":"Database Diagram (Example)","text":"<pre><code>graph LR\n    User[End User] --&gt; MS[Microservice]\n    MS --&gt; Auth[Central Site Auth]\n    MS --&gt; DB[(Service DB)]\n    DB -- \"tenant_id filtering\" --&gt; Data[Tenant Data]</code></pre>"},{"location":"ci-cd/","title":"CI/CD &amp; Release Strategy","text":"<p>Automated pipelines are managed via GitHub Actions to ensure high code quality and consistent releases.</p>"},{"location":"ci-cd/#pipeline-overview","title":"Pipeline Overview","text":"<p>The main workflow (<code>.github/workflows/ci.yml</code>) executes the following steps: 1.  Test: Runs Pytest (TDD) and Behave (BDD). 2.  Report: Generates and uploads Allure test reports. 3.  Build &amp; Publish: Builds the OCI image using Buildah and publishes it to GitHub Container Registry (GHCR).</p> <p>[!TIP] Images are automatically tagged based on the branch (e.g., <code>latest</code>, <code>develop</code>, <code>version-15</code>) and are stored at <code>ghcr.io/&lt;owner&gt;/frappe-microservice-lib</code>.</p> <p>The framework follows a Frappe-style branching model for managing versions:</p> Branch Image Tag Build Argument (<code>${FRAAPE_VERSION}</code>) Purpose <code>develop</code> <code>develop</code> <code>develop</code> Active development <code>version-15</code> <code>version-15</code> <code>version-15</code> Stable V15 release <code>main</code> <code>latest</code> <code>version-15</code> Current stable release Tags (<code>v*</code>) <code>latest</code> <code>version-15</code> Production tags"},{"location":"ci-cd/#dynamic-build-arguments","title":"Dynamic Build Arguments","text":"<p>The <code>Containerfile</code> uses <code>ARG</code> for framework versions. The CI pipeline automatically passes the branch name as the version to ensure the library built for a specific branch depends on the correct core framework version.</p>"},{"location":"ci-cd/#testing-locally-with-act","title":"Testing Locally with Act","text":"<p>You can run the entire pipeline on your local machine using <code>act</code>.</p> <p><pre><code># Run the test job locally\nact -j test --container-architecture linux/arm64\n</code></pre> (Requires <code>act</code> and a Docker-compatible engine like Podman)</p>"},{"location":"development/","title":"Developer Guide","text":""},{"location":"development/#local-development-environment","title":"Local Development Environment","text":"<p>The project is fully pre-configured for VS Code Dev Containers.</p>"},{"location":"development/#features","title":"Features","text":"<ul> <li>Frappe &amp; ERPNext v15 pre-installed.</li> <li>Python 3.11 environment.</li> <li>Allure CLI for local report generation.</li> <li><code>act</code> for local pipeline testing.</li> </ul>"},{"location":"development/#usage","title":"Usage","text":"<ol> <li>Open the project in VS Code.</li> <li>Click \"Reopen in Container\" when prompted.</li> <li>The environment will automatically set up and install dependencies in editable mode.</li> </ol>"},{"location":"development/#running-tests","title":"Running Tests","text":"<p>Tests are organized into TDD (Pytest) and BDD (Behave).</p>"},{"location":"development/#tdd-unit-tests","title":"TDD Unit Tests","text":"<pre><code>PYTHONPATH=. pytest --alluredir=allure-results tests/\n</code></pre>"},{"location":"development/#bdd-behavioral-tests","title":"BDD Behavioral Tests","text":"<pre><code>PYTHONPATH=. behave -f allure_behave.formatter:AllureFormatter -o allure-results features/\n</code></pre>"},{"location":"development/#viewing-reports","title":"Viewing Reports","text":"<pre><code># Serves the visual report at http://localhost:PORT\nallure serve allure-results\n</code></pre>"},{"location":"development/#manual-verification-with-podman-compose","title":"Manual Verification with Podman Compose","text":"<p>You can verify the dev environment orchestration outside of VS Code:</p> <pre><code># Start the environment\npodman compose -f .devcontainer/docker-compose.yml up -d\n\n# Check framework versions\npodman exec devcontainer-devcontainer-1 pip list | grep -E \"frappe|erpnext\"\n\n# Stop the environment\npodman compose -f .devcontainer/docker-compose.yml down\n</code></pre>"},{"location":"features/","title":"Core Features","text":""},{"location":"features/#document-controllers","title":"Document Controllers","text":"<p>Document Controllers allow you to organize your business logic into Frappe-style classes.</p> <pre><code># controllers/sales_order.py\nfrom frappe_microservice.controller import DocumentController\n\nclass SalesOrder(DocumentController):\n    def validate(self):\n        if not self.customer:\n            self.throw(\"Customer is required\")\n</code></pre> <p>Register them in your <code>server.py</code>: <pre><code>from frappe_microservice import setup_controllers\nsetup_controllers(app, controllers_directory=\"./controllers\")\n</code></pre></p>"},{"location":"features/#document-hooks","title":"Document Hooks","text":"<p>Add custom logic to lifecycle events without modifying core frameworks.</p> <pre><code>@app.tenant_db.on('Sales Order', 'before_insert')\ndef set_order_defaults(doc):\n    if not doc.status:\n        doc.status = 'Draft'\n</code></pre> <p>Supported events include <code>before_validate</code>, <code>validate</code>, <code>before_insert</code>, <code>after_insert</code>, <code>before_update</code>, <code>after_update</code>, <code>before_delete</code>, and <code>after_delete</code>.</p>"},{"location":"features/#standardized-error-handling","title":"Standardized Error Handling","text":"<p>All framework responses follow a consistent JSON format:</p> <pre><code>{\n  \"status\": \"error\",\n  \"message\": \"Human readable message\",\n  \"type\": \"ExceptionClass\",\n  \"code\": 4xx\n}\n</code></pre> <p>The framework automatically maps Frappe exceptions to appropriate HTTP status codes: - <code>PermissionError</code> -&gt; 403 - <code>DoesNotExistError</code> -&gt; 404 - <code>ValidationError</code> -&gt; 400 - Authentication failures -&gt; 401</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Central Site: A running Frappe site that acts as the authentication provider.</li> <li><code>saas_platform</code> App: The Central Site MUST have the <code>saas_platform</code> app installed, as it provides the <code>tenant_id</code> field for users.</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/varkrish/frappe-microservice-lib.git\ncd frappe-microservice-lib\npip install -e .\n</code></pre>"},{"location":"getting-started/#production-deployment-docker","title":"Production Deployment (Docker)","text":"<p>The framework is designed to be built into a Docker image using the provided <code>Containerfile</code>. See CI/CD &amp; Release Strategy for automated tagging details.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#basic-microservice","title":"Basic Microservice","text":"<pre><code>from frappe_microservice import create_microservice\n\n# Initialize microservice\napp = create_microservice(\"my-service\")\n\n# Create a secure endpoint (authentication required via Central Site)\n@app.secure_route('/hello', methods=['GET'])\ndef hello(user):\n    \"\"\"User is automatically injected after authentication\"\"\"\n    return {\"message\": f\"Hello {user}!\"}\n\n# Start the service\nif __name__ == '__main__':\n    app.run()\n</code></pre>"},{"location":"getting-started/#automatic-crud-with-resource-api","title":"Automatic CRUD with Resource API","text":"<p>The most powerful feature is the ability to expose any Frappe DocType as a REST resource with a single line:</p> <pre><code>from frappe_microservice import create_microservice\n\napp = create_microservice(\"orders-service\")\n\n# Register a DocType for automatic CRUD\napp.register_resource(\"Sales Order\")\n\n# This automatically creates secure, tenant-isolated endpoints:\n# GET    /api/resource/sales-order        - List\n# POST   /api/resource/sales-order        - Create\n# GET    /api/resource/sales-order/{name} - Get\n# PUT    /api/resource/sales-order/{name} - Update\n# DELETE /api/resource/sales-order/{name} - Delete\n\napp.run()\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>The framework uses environment variables for easy containerization:</p> Variable Description Default <code>FRAPPE_SITE</code> The Frappe site name <code>FRAPPE_SITES_PATH</code> Path to the bench sites directory <code>CENTRAL_SITE_URL</code> URL of the Central Site for Auth <code>DB_HOST</code> Database host for the service <code>LOG_LEVEL</code> Logging level (DEBUG, INFO, etc.) <code>INFO</code> <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> OTLP Exporter URL"},{"location":"observability/","title":"Observability","text":"<p>The framework includes built-in support for distributed tracing and structured logging.</p>"},{"location":"observability/#opentelemetry-otel","title":"OpenTelemetry (OTEL)","text":"<p>Instrumentation is provided for Flask and database operations.</p>"},{"location":"observability/#configuration","title":"Configuration","text":"<p>Set the following environment variable to point to your OTLP collector: <pre><code>export OTEL_EXPORTER_OTLP_ENDPOINT=\"http://jaeger-host:4317\"\n</code></pre></p>"},{"location":"observability/#automatic-spans","title":"Automatic Spans","text":"<ul> <li>Web Requests: All incoming HTTP requests are automatically instrumented.</li> <li>Database Operations: <code>TenantAwareDB</code> methods (<code>get_all</code>, <code>get_doc</code>, <code>insert_doc</code>) create manual spans with metadata (DocType, tenant_id).</li> </ul>"},{"location":"observability/#logging","title":"Logging","text":"<p>Logging is pre-configured and respects the <code>LOG_LEVEL</code> environment variable.</p> <pre><code>export LOG_LEVEL=DEBUG\n</code></pre> <p>The application logger is configured to output to standard output in a format suitable for container logs.</p>"}]}